*textobj-user.txt*	Create your own text objects

Version @@VERSION@@
Script ID: 2100
Copyright (C) 2007-2013 Kana Natsuno <http://whileimautomaton.net/>
License: MIT license  {{{
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}}

CONTENTS					*textobj-user-contents*

Introduction		|textobj-user-introduction|
Philosophy		|textobj-user-philosophy|
Reference		|textobj-user-reference|
Obsolete API		|textobj-user-obsolete-api|
Known issues		|textobj-user-known-issues|
Changelog		|textobj-user-changelog|




==============================================================================
INTRODUCTION					*textobj-user-introduction*

*textobj-user* is a Vim plugin to create your own text objects without pain.
It is hard to create text objects, because there are many pitfalls to deal
with.  This plugin hides such details and provides a declarative way to define
text objects.  You can use regular expressions to define simple text objects,
or use functions to define complex ones.  For example...

						*textobj-user-example-simple*
(a) Define "ad"/"id" to select a date such as "2013-03-16", and
    define "at"/"it" to select a time such as "22:04:21":
>
	call textobj#user#define('datetime', {
	\   'date': {
	\     'pattern': '\<\d\d\d\d-\d\d-\d\d\>',
	\     'select': ['ad', 'id'],
	\   },
	\   'time': {
	\     'pattern': '\<\d\d:\d\d:\d\d\>',
	\     'select': ['at', 'it'],
	\   },
	\ })
<
						*textobj-user-example-between*
(b) Define "aP" to select a PHP code with "<?php" and "?>", and
    define "iP" to select a PHP code without "<?php" and "?>":
>
	call textobj#user#define('php', {
	\   'code': {
	\     'pattern': ['<?php\>', '?>'],
	\     'select-a': 'aP',
	\     'select-i': 'iP',
	\   },
	\ })
<
						*textobj-user-example-complex*
(c) Define "al" to select the current line, and
    define "il" to select the current line without indentation:
>
	call textobj#user#define('line', {
	\   '-': {
	\     'select-a-function': 'CurrentLineA',
	\     'select-a': 'aP',
	\     'select-i-function': 'CurrentLineI',
	\     'select-i': 'iP',
	\   },
	\ })

	function! CurrentLineA()
	  normal! 0
	  let head_pos = getpos('.')
	  normal! $
	  let tail_pos = getpos('.')
	  return ['v', head_pos, tail_pos]
	endfunction

	function! CurrentLineI()
	  normal! ^
	  let head_pos = getpos('.')
	  normal! g_
	  let tail_pos = getpos('.')
	  let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
	  return
	  \ non_blank_char_exists_p
	  \ ? ['v', head_pos, tail_pos]
	  \ : 0
	endfunction
<

You can define your own text objects like the above examples.
See also |textobj-user-reference| for more details.

There are many text objects written with textobj-user.  If you want to find
useful ones, or to know how they are implemented, see the following page:
https://github.com/kana/vim-textobj-user/wiki


Requirements:
- Vim 7.0 or later

Latest version:
https://github.com/kana/vim-textobj-user

Document in HTML format:
http://vim-doc.heroku.com/view?https://raw.github.com/kana/vim-textobj-user/master/doc/textobj-user.txt




==============================================================================
PHILOSOPHY					*textobj-user-philosophy*

Suppose that you define custom text objects.  Why do you define them?
You must believe that they are useful and they boost your productivity.
Such text objects are also useful for other users.
If so, why don't you share them as a plugin?

This is the reason why textobj-user provides just one function
|textobj#user#define()|.  It defines not only key mappings like aX/iX for
custom text objects, but also everything that is necessary to share as
a plugin.  For example, one might prefer aY/iY to aX/iX for custom text
objects.  So that it's necessary to provides a way for such cusotmization,
but it's somewhat tedious to define such stuffs by hand.




==============================================================================
REFERENCE					*textobj-user-reference*

						*textobj#user#define()*
textobj#user#define({plugin-name}, {specs})
	Define custom text objects according to {specs}, and
	define also utilities to easily share custom text objects as a plugin
	which name is {plugin-name}.

	{plugin-name} is a string which consists of English alphabets.
	This name is used various key mappings, Ex commands, and variables.

	{specs} is a |Dictionary| for definitions of custom text objects.
	See also |textobj-user-specs| for details.

	For example,
>
		call textobj#user#define('datetime', {
		\   'date': {
		\     'pattern': '\<\d\d\d\d-\d\d-\d\d\>',
		\     'select': ['ad', 'id'],
		\   },
		\   'time': {
		\     'pattern': '\<\d\d:\d\d:\d\d\>',
		\     'select': ['at', 'it'],
		\   },
		\ })
<
	many stuffs are defined with the above definition:

				    *:Textobj{Plugin}DefineDefaultKeyMappings*
	(a) An Ex command :TextobjDatetimeDeineDefaultKeyMappings is defined.
	The Ex command defines default key mappings for custom text objects,
	but it doesn't override existing key mappings unless "!" is given.

	In this example, the Ex command maps "ad", "id", "at" and "it" to
	custom text objects in Operator-pending mode and Visual mode.  ({lhs}
	is also mapped in Select mode if it starts with a non-printable
	character such as <C-d>)

			       *<Plug>(textobj-{plugin}-{object}-{operation})*
	(b) Interface key mappings such as <Plug>(textobj-datetime-date-a) are
	defined in Operator-pending mode, Visual mode and Select mode.  These
	key mappings are defined for extra customization for users.

	For example, one might prefer "aT" and "iT" to select a time, because
	|at| and |it| are bound to the extremely useful text objects by
	default, and it is usually a bad idea to override them.  In this case,
	interface key mappings are used as follows:
>
		xmap aT  <Plug>(textobj-datetime-time-a)
		omap aT  <Plug>(textobj-datetime-time-a)
		xmap iT  <Plug>(textobj-datetime-time-i)
		omap iT  <Plug>(textobj-datetime-time-i)
<
				*g:textobj_{plugin}_no_default_key_mappings*
	(c) Finally :TextobjDatetimeDeineDefaultKeyMappings is executed by
	default to define default key mappings -- "ad", "id", "at" and "it".

	As described in (b), sometimes users do not want to use default key
	mappings such as "at" and "at".  For such users, default key mappings
	are not defined by this function if a variable
	g:textobj_datetime_no_default_key_mappings is set to true.


							  *textobj-user-specs*
Specification for a text object ~

|textobj#user#define()| takes {specs} for custom text objects.  {specs} is
a |Dictionary|, and it is treated as a sequence of key-value pairs, where key
is the name of a text object and value is the specification of a text object.

The specification of a text object consists of various properties.  Properties
are expressed as a single dictionary.  Each key is the name of a property.
The following properties are available:

"move-n"			{lhs} or [{lhs}, ...]
	The value must be a string or a list of strings.  Each string is
	treated as a {lhs} of a default key mapping to move the cursor to the
	next text object.

	A target text object is determined by
	- the "pattern" property with a single regular expression, or
	- the "move-n-function" property.

"move-p"			{lhs} or [{lhs}, ...]
"move-N"			{lhs} or [{lhs}, ...]
"move-P"			{lhs} or [{lhs}, ...]
	Like "move-n", but {lhs} is used as a default key mapping to move the
	cursor to
	- the previous text object,
	- the end of the next text object, or
	- the end of the previous text object.

"select"			{lhs} or [{lhs}, ...]
	Like "move-n", but {lhs} is used as a default key mapping to select
	the text object under the cursor.  If there is no text object under
	the cursor, the next text object is selected.

	A target text object is determined by
	- the "pattern" property with a single regular expression, or
	- the "select-function" property.

"select-a"			{lhs} or [{lhs}, ...]
"select-i"			{lhs} or [{lhs}, ...]
	Like "select", but {lhs} is used as a default key mapping to select
	"a" text object or "inner" text object, like |ab|, |ip| and other
	built-in text objects.

	A target text object is determined by
	- the "pattern" property with a pair of regular expressions,
	- the "select-function-a" property, or
	- the "select-function-i" property.

"pattern"			{regexp} or [{regexp}, {regexp}]
	A single regular expression or a list of two regular expressions to
	determine a target text object.

	With a single regular expression:
		A region matched to the regular expression is treated as
		a target text object.

	With a pair of regular expressions:
		A region between two parts is treated as a target text object,
		where the 1st part is matched to the 1st regular expression
		and the 2nd part is matched to the 2nd regular expression.

"{property}-function"		{fname}
	If this property is defined, the function named {fname} instead of the
	"pattern" property is used to determine a target text object for
	a "{property}" operation.

	The function...
	- Must take no argument, and
	- Must return a list to denote the region occupied by a target text
	  object, or must return 0 to denote that there is no text object.

	The format of a list a list to denote the region is as follows:

		[region_type, start_position, end_position]

	- "region_type" is a string to denote the type of a region.
		Valid value     Meaning     ~
		--------------------------- ~
		"v"             Characterwise
		"V"             Linewise
		"\<C-v>"        Blockwise
	- "start_position" denotes the start position of a region.
	  The detail of this value is the same as |getpos()|.
	- "end_position" is like "start_position", but it denotes the
	  end position of a region.

	See |textobj-user-example-complex| for an example.

"sfile"				{string}
	Value must be expand('<sfile>').  This value is used to
	calculate <SNR> prefix for script-local functions which are
	given to "{property}-function".


				      *textobj-user-migration-from-0.x-to-1.x*
Migrate from version 0.x to version 1.x ~

The API to define custom text objects is changed.
Version 0.x uses |textobj#user#plugin()|, while
version 1.x uses |textobj#user#define()|.
Usage of both functions are roughly equivalent.
Details of {specs} are different for both functions.
To migrate from textobj#user#plugin() to textobj#user#define(),
replace key names in {specs} according to the following table:

textobj#user#plugin()                 textobj#user#define()              ~
------------------------------------------------------------------------ ~
"move-n"                              Same as before.
"move-p"                              Same as before.
"move-N"                              Same as before.
"move-P"                              Same as before.
"select"                              Same as before.
"select-a"                            Same as before.
"select-i"                            Same as before.
"*pattern*"                           "pattern"
"*no-default-key-mappings*"           No longer supported.
"*{spec}-function*"                   "{spec}-function"
"*sfile*"                             "sfile"

Note that "*no-default-key-mappings*" is no longer supported.
Because it is not useful and it seems not to be used by anyone.
Use |g:textobj_{plugin}_no_default_key_mappings|
to suppress default key mappings.




==============================================================================
OBSOLETE API					*textobj-user-obsolete-api*

						*textobj#user#move()*
textobj#user#move({pattern}, {flags}, {previous-mode})
	Note: This function is obsolete.  It will be removed in sometime.

	Move the cursor to the appropriate object defined by {pattern}.

	{flags} is a string, which can contain the following character flags:
		char	meaning ~
		----	------- ~
		'b'     search backward instead of forward.
		'e'     move to the end of the match.

	{previous-mode} is a string representing the "previous" mode,
	that is, which mode of mapping causes the calling of this function.
	For example, if this function is called via a mapping for
	Operator-pending mode, {previous-mode} must be 'o'.
		char	meaning ~
		----	------- ~
		'n'     Normal mode
		'o'     Operator-pending mode
		'v'     Visual mode

	Return value is same as |searchpos()|.

						*textobj#user#select()*
textobj#user#select({pattern}, {flags}, {prevous-mode})
	Note: This function is obsolete.  It will be removed in sometime.

	Select the appropriate object defined by {pattern}.
	If the cursor is already in the range of an object, select it.
	If the cursor is not in the range of an object, select the nearest
	object after the cursor.

	{flags} is a string, which can contain the following character flags:
		char	meaning ~
		----	------- ~
		'b'     select the nearest object BEFORE the cursor if the
		        cursor is not in the range of an object.

	For the detail of {previous-mode}, see |textobj#user#move()|.

	Return value is not defined.

						*textobj#user#select_pair()*
textobj#user#select_pair({pattern1}, {pattern2}, {flags}, {previous-mode})
	Note: This function is obsolete.  It will be removed in sometime.

	Select the appropriate object which starts with {pattern1} and ends
	with {pattern2}.

	{flags} is a string, which can contain the following character flags:
		char	meaning ~
		----	------- ~
		'a'     select the range including {pattern1} and {pattern2},
			like |at|.
		'i'     select the range excluding {pattern1} and {pattern2},
			like |it|.  This is the default behavior unless 'a' is
			explicitly specified.  If the cursor is not in a text
			between {pattern1} and {pattern2}, this function does
			nothing.

	For the detail of {previous-mode}, see |textobj#user#move()|.

	Return value is not defined.

						*textobj#user#plugin()*
textobj#user#plugin({plugin}, {obj-specs})
	Define key mappings and a command to support writing a plugin which
	provides various user-defined text objects.
	
	Example: If textobj#user#plugin() is called like the following: >

		call textobj#user#plugin('foo', {
		\   'cdata': {
		\     '*pattern*': ['<!\[CDATA\[', '\]\]>'],
		\     'select-a': 'aC',
		\     'select-i': 'iC',
		\   },
		\   'date': {
		\     '*pattern*': '\<\d\{4}-\d\{2}-\d\{2}\>',
		\     'select': ['ad', 'id'],
		\   },
		\   'helptag': {
		\     '*pattern*': '\*[^*]\+\*',
		\     'move-n': ',j',
		\     'move-p': ',k',
		\     'move-N': ',J',
		\     'move-P': ',K',
		\   },
		\   '-': {
		\     '*select-function*': 'SelectFoo',
		\     'select': ['ax', 'ix'],
		\   },
		\ })
<
		(1) New command :TextobjFooDefaultKeyMappings will be defined.
		This command defines the following key mappings as the default
		ones for the new text objects (this command doesn't override
		existing {lhs}s unless "!" is given): >

			omap aC  <Plug>(textobj-foo-cdata-a)
			vmap aC  <Plug>(textobj-foo-cdata-a)
			omap iC  <Plug>(textobj-foo-cdata-i)
			vmap iC  <Plug>(textobj-foo-cdata-i)
			omap ad  <Plug>(textobj-foo-date)
			vmap ad  <Plug>(textobj-foo-date)
			omap id  <Plug>(textobj-foo-date)
			vmap id  <Plug>(textobj-foo-date)
			omap ax  <Plug>(textobj-foo)
			vmap ax  <Plug>(textobj-foo)
			omap ix  <Plug>(textobj-foo)
			vmap ix  <Plug>(textobj-foo)
			map ,j  <Plug>(textobj-foo-helptag-n)
			map ,k  <Plug>(textobj-foo-helptag-p)
			map ,J  <Plug>(textobj-foo-helptag-N)
			map ,K  <Plug>(textobj-foo-helptag-P)
<
		(2) New variable g:__textobj_foo will be defined.  This is
		a dictionary which contains various functions and values.

		(3) Key mappings <Plug>(textobj-foo-...) which execute
		appropriate actions will be defined if "*pattern*" or
		"*{spec}-function*" is given for a {spec}.  Otherwise,
		<Plug>(textobj-foo-...) will not be defined.

		(4) :TextobjFooDefaultKeyMappings will be executed unless
		{specs} contains the key "*no-default-key-mappings" or the
		variable g:textobj_foo_no_default_key_mappings is defined.

	{plugin} is the name of a plugin.  It must be a string which consits
	of only lowercase alphabets.

	{obj-specs} is a dictionary (and given value is cached by this
	plugin, so you have to pass copied one if necessary).  In this
	dictionary, each key/value pair expresses one text object:
	- each key is a string of the name of the text object, and
	- each value (called as "specs") is a dictionary which denotes some
	  details of the text object.

	The following specs are available:

	"move-n"	{lhs} or [{lhs}, ...]
		A string which is a key sequence to move the cursor to the
		next text object.  If the value is a list of strings, each
		string is mapped to move the cursor.

	"move-p"	{lhs} or [{lhs}, ...]
	"move-N"	{lhs} or [{lhs}, ...]
	"move-P"	{lhs} or [{lhs}, ...]
		Like "move-n", but each string is treated as a key sequence to
		move the cursor to the previous text object, the end of the
		next text object, or the end of the previous text object.

	"select"	{lhs} or [{lhs}, ...]
		Like "move-n", but each string is treated as a key sequence to
		select the text object.

	"select-a"	{lhs} or [{lhs}, ...]
	"select-i"	{lhs} or [{lhs}, ...]
		Like "select", but each string is treated as a key sequence
		to select "a" text object or "inner" text object.

	"*pattern*"	{regexp} or [{regexp}, {regexp}]
		A regular expression which matches to a text object.  If the
		value is a list of two regular expressions, it denotes that
		the text object starts with the first regular expression and
		ends with the second regular expression.

	"*no-default-key-mappings*"	anything
		If this key exists, :Textobj{Plugin}DefaultKeyMappings will
		not be executed when textobj#user#plugin() is called.  The
		corresponding value doesn't matter.

	"*{spec}-function*"	{fname}
		If this key exists, use the function named {fname} instead of
		the default algorithm based on regular expression to select
		a text for {spec}.

		The function must take no argument and it must return a list
		to denote the area to be selected or 0 to denote that there is
		nothing to select.  The detail of a list is as follows:
			[motion_type, start_position, end_position]
		- "motion_type" denotes the default type of motion.  Valid
		  values are "v", "V" or "\<C-v>".  The meaning of the values
		  are characterwise, linewise or blockwise.
		- "start_position" denotes the start position of the area to
		  be selected.  The detail of this value is the same as
		  |getpos()|.
		- "end_position" is like "start_position", but it denotes the
		  end position of the area to be selected.

		Example definition: >
			funcion! SelectSomething()
			  if SomethinWrong()
			    return 0
			  endif

			  return ['v', getpos("'["), getpos("']")]
			endfunction
<
	"*sfile*"	{string}
		Value must be expand('<sfile>').  This value is used to
		calculate <SNR> prefix for script-local functions which are
		specified "*{spec}-function*".




==============================================================================
KNOWN ISSUES					*textobj-user-known-issues*

- Count is not supported to select a text object.

- Unlike built-in text objects such as |aw|, |ip| and others,
  visually selected region is not extended by repeating custom text objects.

- Custom text objects with |o_CTRL-V| may not work properly.

- See also: https://github.com/kana/vim-textobj-user/issues




==============================================================================
CHANGELOG					*textobj-user-changelog*

1.0.0	2013-03-16T22:48:38+09:00		*textobj-user-changelog-1.0.0*
	- |textobj#user#define()| is completely rewritten to provide more
	  intuitive interface to define custom text objects as a plugin.
	  Usage of this function is no longer compatible with old versions.
	  It is highly recommended to use textobj#user#define() instead of
	  textobj#user#plugin().
	- |textobj#user#plugin()| becomes obsolete now.
	  Use |textobj#user#define()| instead.
	  It is not difficult to migrate to new API.
	  See also |textobj-user-migration-from-0.x-to-1.x| for details.

0.3.12	2012-01-18T19:34:29+09:00		*textobj-user-changelog-0.3.12*
	- |textobj#user#plugin()|: Fix the bug that "*sfile*" is not correctly
	  interpreted in a Unix-like environment on Microsoft Windows such as
	  Git for Windows.  (Thank sgur for reporting this problem.  See also:
	  https://github.com/kana/vim-textobj-user/pull/5)

0.3.11	2012-01-17T21:02:18+09:00		*textobj-user-changelog-0.3.11*
	- |textobj#user#plugin()|: Fix the bug that "move-n" and "move-p"
	  operations for text objects are not correctly defined if
	  'ignorecase' is enabled.  (Thank h1mesuke for reporting this
	  problem.  See also: https://github.com/kana/vim-textobj-user/pull/4)

0.3.10	2011-07-20T22:24:42+09:00		*textobj-user-changelog-0.3.10*
	- Update for Vim 7.3.233 or later.
	  (Thank cehoffman and thinca for reporting this problem.)

0.3.9	2010-04-19T22:02:03+09:00		*textobj-user-changelog-0.3.9*
	- |textobj#user#plugin()|: Fix not to define key mappings in Select
	  mode if appropriate.  Now it works smoothly with plugins which
	  utilize and depend on the default behavior in Select mode.

0.3.8	2009-07-18T10:02:40+09:00		*textobj-user-changelog-0.3.8*
	- Fix a bug that it was not possible to select any range which starts
	  with the end of a line.
	- |textobj#user#plugin()|: Fix a bug that it did not accept
	  any function which is not script-local as a value for
	  "*{spec}-function*".

0.3.7	2008-10-24T02:25:59+09:00		*textobj-user-changelog-0.3.7*
	- |textobj#user#select()|: Fix a bug that it didn't select an object
	  which: (1) matches to multiple lines and (2) contains the cursor.
	- |textobj#user#select()|, |textobj#user#select_pair()|,
	  |textobj#user#plugin()| with "*{spec}-function*":
	  Support |o_v| and others.  To use this feature, you have to apply
	  the following patch to Vim:
	  http://github.com/kana/vim/commits/hack/vimvar-motion_force

0.3.6	2008-08-31T03:17:55+09:00		*textobj-user-changelog-0.3.6*
	- Remove unnecessary messages for some cases.  They were just for
	  debugging.

0.3.5	2008-08-24T23:01:45+09:00		*textobj-user-changelog-0.3.5*
	Incompatible changes with 0.3.4 or ealier:
	- |textobj#user#plugin()|: Change the specification of functions for
	  "*{spec}-function*".

	Other changes:
	- |textobj#user#plugin()|: Add missing description of functions for
	  "*{spec}-function*".

0.3.4	2008-06-26T14:13:33+09:00		*textobj-user-changelog-0.3.4*
	- |textobj#user#plugin()|:
	  - Add "*{spec}-function*" to customize the way to move the cursor or
	    to select a text by the given function instead of regular
	    expression based selection.

0.3.3	2008-06-11T21:16:53+09:00		*textobj-user-changelog-0.3.3*
	- |textobj#user#plugin()|:
	  - Rename the spec "*pattern*" instead of "pattern".
	  - Fix incorrect processing on "*no-default-key-mappings*".

0.3.2	2008-06-11T02:53:41+09:00		*textobj-user-changelog-0.3.2*
	- |textobj#user#plugin()|: Change the names of interface mappings for
	  the text object of which name is '-'.
	  Old: <Plug>(textobj-{plugin}---a)
	  New: <Plug>(textobj-{plugin}-a)

0.3.1	2008-06-08T22:05:02+09:00		*textobj-user-changelog-0.3.1*
	- |textobj#user#plugin()|: Execute :Textobj{Plugin}DefaultKeyMappings
	  if necessary.

0.3	2008-06-04T21:16:02+09:00		*textobj-user-changelog-0.3*
	- |textobj#user#plugin()|: New.
	- |textobj#user#define()|: Now obsolete.  Use textobj#user#define().

0.2.2	2008-06-02T06:26:12+09:00		*textobj-user-changelog-0.2.2*
	- Fix wrong sentences in the document.

0.2.1	2008-05-22T00:17:24+09:00		*textobj-user-changelog-0.2.1*
	- textobj#user#select_pair(): Fix the bug that it selects wrong text
	  in Operator-pending mode.

0.2	2008-01-07T08:44:14+09:00		*textobj-user-changelog-0.2*
	- textobj#user#select(): Fix the wrong selecting in Operator-pending
	  mode.
	- textobj#user#move(): Modify to be able to use in Visual and
	  Operator-pending mode.

0.1	2007-11-16T01:17:45+09:00		*textobj-user-changelog-0.1*
	- Modify to be autoloaded.
	- Change the names of all API.

0.0	2007-10-15T20:41:34+09:00		*textobj-user-changelog-0.0*
	- First release.




==============================================================================
vim:tw=78:ts=8:ft=help:norl:fen:fdl=0:fdm=marker:
